<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session 9cd16fa3-8789-4ee3-b1de-6f8f6b5e3949 (2026-02-24 03:16Z) -->

# Code Duplication in Validation Logic Refactor (2026-02-24 03:16Z)

_**User (2026-02-24 03:17Z)**_


### [IMPORTANT] Code duplication in validation logic
**File:** crates/core/src/validation/mod.rs
**Line:** 59-170
**Issue:** The selector parsing logic (`selector_column_references`, `find_operator`, `normalize_column_name`, `unquote`) duplicates code from `crates/core/src/dsl/mod.rs`. This violates DRY and risks inconsistency if the DSL evolves (e.g. to support complex expressions).
**Suggested fix:** Refactor `crates/core/src/dsl/mod.rs` to expose `find_operator`, `normalize_column_name`, and `unquote` as public (or `pub(crate)`) functions, and reuse them in `crates/core/src/validation/mod.rs`.


---

_**Agent (model copilot/gpt-5.3-codex)**_

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///home/marcos/Projects/.worktrees/dobonomodo-S06/crates/core/src/dsl/mod.rs)</summary>


Read [](file:///home/marcos/Projects/.worktrees/dobonomodo-S06/crates/core/src/dsl/mod.rs)

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="copilot_readFile">
<details>
<summary>Tool use: **copilot_readFile** • Reading [](file:///home/marcos/Projects/.worktrees/dobonomodo-S06/crates/core/src/validation/mod.rs)</summary>


Read [](file:///home/marcos/Projects/.worktrees/dobonomodo-S06/crates/core/src/validation/mod.rs)

</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Generating patch (12 lines) in [](file:///home/marcos/Projects/.worktrees/dobonomodo-S06/crates/core/src/dsl/mod.rs)</summary>

```rust
use std::collections::BTreeMap;

use anyhow::{bail, Result};
use polars::prelude::{col, lit, Expr};

const COMPARISON_OPERATORS: [&str; 7] = [">=", "<=", "!=", "==", "=", ">", "<"];

pub fn module_name() -> &'static str {
    "dsl"
}

pub fn resolve_selector_reference(
    selector: &str,
    selectors: &BTreeMap<String, String>,
) -> Result<String> {
    let selector = selector.trim();
    let Some(reference) = selector
        .strip_prefix("{{")
        .and_then(|value| value.strip_suffix("}}"))
    else {
        return Ok(selector.to_string());
    };

    let reference = reference.trim();
    if reference.is_empty() {
        bail!("selector reference cannot be empty");
    }

    selectors
        .get(reference)
        .cloned()
        .ok_or_else(|| anyhow::anyhow!("unknown selector reference: {reference}"))
}

pub fn compile_selector(selector: &str) -> Result<Expr> {
    let selector = selector.trim();
    if selector.is_empty() {
        bail!("selector cannot be empty");
    }

    if selector.eq_ignore_ascii_case("true") {
        return Ok(lit(true));
    }
    if selector.eq_ignore_ascii_case("false") {
        return Ok(lit(false));
    }

    let Some((index, operator)) = find_operator(selector) else {
        bail!("unsupported selector expression: {selector}");
    };

    let left_name = normalize_column_name(&selector[..index])?;
    let right_expr = parse_value_operand(&selector[index + operator.len()..])?;
    let left_expr = col(left_name.as_str());

    let compiled = match operator {
        "=" | "==" => left_expr.eq(right_expr),
        "!=" => left_expr.neq(right_expr),
        ">" => left_expr.gt(right_expr),
        "<" => left_expr.lt(right_expr),
        ">=" => left_expr.gt_eq(right_expr),
        "<=" => left_expr.lt_eq(right_expr),
        _ => unreachable!("operator should be matched above"),
    };

    Ok(compiled)
}

fn parse_value_operand(raw: &str) -> Result<Expr> {
    let value = raw.trim();
    if value.is_empty() {
        bail!("selector value cannot be empty");
    }

    if let Some(unquoted) = unquote(value) {
        return Ok(lit(unquoted.to_string()));
    }

    if value.eq_ignore_ascii_case("true") {
        return Ok(lit(true));
    }
    if value.eq_ignore_ascii_case("false") {
        return Ok(lit(false));
    }

    if let Ok(parsed) = value.parse::<i64>() {
        return Ok(lit(parsed));
    }

    if let Ok(parsed) = value.parse::<f64>() {
        return Ok(lit(parsed));
    }

    Ok(col(normalize_column_name(value)?.as_str()))
}

pub(crate) fn find_operator(selector: &str) -> Option<(usize, &'static str)> {
    let mut in_single = false;
    let mut in_double = false;
    let mut escaped = false;

    for (index, ch) in selector.char_indices() {
        if escaped {
            escaped = false;
            continue;
        }

        if ch == '\\' {
            escaped = true;
            continue;
        }

        if ch == '\'' && !in_double {
            in_single = !in_single;
            continue;
        }

        if ch == '"' && !in_single {
            in_double = !in_double;
            continue;
        }

        if in_single || in_double {
            continue;
        }

        for operator in COMPARISON_OPERATORS {
            if selector[index..].starts_with(operator) {
                return Some((index, operator));
            }
        }
    }

    None
}

pub(crate) fn normalize_column_name(raw: &str) -> Result<String> {
    let name = raw.trim();
    if name.is_empty() {
        bail!("selector column cannot be empty");
    }

    if name.contains(' ') {
        bail!("selector column cannot contain spaces: {name}");
    }

    let normalized = name.rsplit('.').next().unwrap_or(name).trim();
    if normalized.is_empty() {
        bail!("selector column cannot be empty");
    }

    Ok(normalized.to_string())
}

pub(crate) fn unquote(value: &str) -> Option<&str> {
    if value.len() < 2 {
        return None;
    }

    if value.starts_with('"') && value.ends_with('"') {
        return Some(&value[1..value.len() - 1]);
    }

    if value.starts_with('\'') && value.ends_with('\'') {
        return Some(&value[1..value.len() - 1]);
    }

    None
}

```


</details>
</tool-use>

---

<tool-use data-tool-type="write" data-tool-name="copilot_applyPatch">
<details>
<summary>Tool use: **copilot_applyPatch** • Using "Apply Patch"</summary>

_No content to show_

</details>
</tool-use>

---

**Planning targeted file updates**I’ll remove the duplicated selector helper logic by exposing the shared parsing helpers from the DSL module and switching validation to call those helpers directly, then run tests for the touched crate.**Making DSL functions pub(crate) and deduplicating**I’ve identified the exact duplicated helpers; next I’m patching both modules so validation imports and reuses DSL helpers instead of maintaining a parallel implementation.

---

